/*
 * Each new term in the Fibonacci sequence is generated by adding the previous two terms. By starting with 1 and 2, the first 10 terms will be:
 *
 * 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, ...

  * By considering the terms in the Fibonacci sequence whose values do not exceed four million, find the sum of the even-valued terms.
  */

  // (over) design principles for learning go
  // a method that generates fibonacci numbers in sequence
  // it should take a channel and a filter function
  // if the fibonacci number passes the filter function, send it to the channel
  // channel listener simply adds numbers coming down the pipe
  // ^^ reusable for other methods (retrofit multiples3and5)
  // stop function should determine if it's time to stop finding fibonacci numbers
  // add tests

package main

import (
  "euler_utils"
  "fmt"
)

func main() {
  outputChannel := make(chan int)
  go generateFibs(4000000, outputChannel, func (number int) bool {
    return isEven(number)
  })

  sumChannelValues(outputChannel)
}

func sumChannelValues(channel chan int) {
  runningSum := 0

  for value := range channel {
    runningSum += value
  }

  fmt.Println(runningSum)
}

func isEven(number int) bool {
  return number % 2 == 0
}

// generates fibonaccis until the given fibonacci is greater than
// upToFibValue
func generateFibs(upToFibValue int, outputChannel chan int, doSendFilter func(number int) bool) {
  fib1, fib2 := 1, 2
  euler_utils.SendValueToChannel(fib1, outputChannel, doSendFilter)
  euler_utils.SendValueToChannel(fib2, outputChannel, doSendFilter)

  for fib2 < upToFibValue {
    fib1, fib2 = fib2, fib2 + fib1
    euler_utils.SendValueToChannel(fib2, outputChannel, func (number int) bool {
      return fib2 <= upToFibValue && doSendFilter(number)
    })
  }

  close(outputChannel)
}
